# BFMC E2E Model Configuration (YOLO Style)
# Parameters
nc: 14  # number of classes
nm: 4   # number of commands (for PromptEncoder)
nw: 10  # number of waypoints

# Backbone
# [from, repeats, module, args]
backbone:
  # Using TIMM backbone wrapper
  # args: [model_name, pretrained, features_only, out_indices]
  - [-1, 1, TimmBackbone, ['mobilenetv4_conv_small.e2400_r224_in1k', True, True]]
  # Output features: [c2, c3, c4, c5] channels

# Head
head:
  # PANet/FPN Neck
  - [-1, 1, SPPF, [128, 5]] # 1 (P5)
  - [-1, 1, nn.Upsample, [None, 2, 'bilinear']] # 2
  - [[-1, 2], 1, Concat, [1]] # 3 (cat P5_up, P4) (index 2 is P4 from backbone? No, backbone returns list)
  # Actually, with TimmBackbone, we need a way to select specific features.
  # Let's assume TimmBackbone returns a list of features.
  # But YOLO parser usually works layer by layer.

  # Alternative: Define full structure layer by layer like YOLO?
  # Or use a special "Input" layer that grabs from backbone?

  # Standard YOLO format:
  # [from, repeats, module, args]

  # Let's simplify: The generic parser will handle standard modules.
  # For TIMM, we might need a distinct approach or purely definition based.

  # Let's stick to the current successful architecture first but exposed in YAML?
  # Or just parameters?

  # User wants "replace layers, number of layers easily".
  # So full definition is best.

  # Let's define the Custom Blocks in models/common.py first then usage here.
  # But for now, let's keep it simple: Configuration of PARAMETERS first.

  # Wait, User said "replace layers, number of layers".
  # I MUST implement the list-based config.

model:
  # Backbone
  - [-1, 1, Conv, [32, 3, 2]]  # 0-P1/2
  - [-1, 1, Conv, [64, 3, 2]]  # 1-P2/4
  - [-1, 1, C3k2, [64, 1]]      # 2
  - [-1, 1, Conv, [128, 3, 2]] # 3-P3/8
  - [-1, 2, C3k2, [128, 1]]     # 4
  - [-1, 1, Conv, [256, 3, 2]] # 5-P4/16
  - [-1, 2, C3k2, [256, 1]]     # 6
  - [-1, 1, Conv, [512, 3, 2]] # 7-P5/32
  - [-1, 1, C3k2, [512, 1]]     # 8
  - [-1, 1, SPPF, [512, 5]]     # 9

  # Neck
  - [-1, 1, nn.Upsample, [None, 2, 'bilinear']] # 10
  - [[-1, 6], 1, Concat, [1]] # 11 cat backbone P4
  - [-1, 1, C3k2, [256, 1]] # 12

  - [-1, 1, nn.Upsample, [None, 2, 'bilinear']] # 13
  - [[-1, 4], 1, Concat, [1]] # 14 cat backbone P3
  - [-1, 1, C3k2, [128, 1]] # 15 (P3)

  # Heads
  - [[15, 12, 9], 1, Detect, [nc]] # Detect(P3, P4, P5)
